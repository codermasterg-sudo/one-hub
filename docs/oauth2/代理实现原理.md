# OAuth2 代理实现原理

## 支持的代理类型

### 1. HTTP/HTTPS 代理

**使用场景**：最常见的代理类型，适用于大多数场景

**示例配置**：
```
http://127.0.0.1:7890
https://proxy.example.com:8080
http://username:password@proxy.example.com:8080
```

**实现原理**：
- 使用 Go 标准库 `net/http` 的 `Transport.Proxy` 函数
- 通过 HTTP CONNECT 方法建立隧道连接
- 适用于 HTTPS 请求（通过 CONNECT 隧道加密）

**代码位置**：`common/utils/proxy.go:21-38`

### 2. SOCKS5 代理

**使用场景**：更底层的代理协议，支持 TCP/UDP

**示例配置**：
```
socks5://127.0.0.1:7891
socks5://username:password@proxy.example.com:1080
```

**实现原理**：
- 使用 `golang.org/x/net/proxy` 包
- 通过 `Transport.DialContext` 劫持 TCP 连接
- 在建立连接时通过 SOCKS5 代理服务器中转

**代码位置**：`common/utils/proxy.go:40-62`

## Clash 支持说明

### Clash 是什么？

Clash 是一个跨平台的代理客户端，支持多种代理协议（Shadowsocks、VMess、Trojan 等），并提供：
- 规则分流（根据域名/IP 自动选择直连或代理）
- 负载均衡（自动选择最快的节点）
- 本地代理接口（HTTP/SOCKS5）

### One Hub 如何使用 Clash？

**架构图**：
```
One Hub → Clash 本地代理 → 代理节点 → 目标服务器
         (127.0.0.1:7890)   (远程节点)   (Claude API)
```

**配置方式**：

1. **查看 Clash 端口配置**

打开 Clash 配置文件（通常是 `config.yaml`）：
```yaml
port: 7890           # HTTP 代理端口
socks-port: 7891     # SOCKS5 代理端口
mixed-port: 7892     # 混合端口（HTTP + SOCKS5）
allow-lan: false     # 是否允许局域网连接
```

2. **在 One Hub 中配置**

在渠道配置的"代理"字段中填入：
```
http://127.0.0.1:7890
```

或者使用 SOCKS5：
```
socks5://127.0.0.1:7891
```

3. **Clash 自动处理**

Clash 会根据规则自动：
- 判断是否需要代理（直连或走代理）
- 选择最优节点
- 处理连接失败重试
- 记录流量统计

## 实现原理详解

### 架构层次

```
┌─────────────────────────────────────────────────────┐
│  Application Layer (OAuth2 Provider)                │
│  ├─ ClaudeOAuth2Provider                           │
│  └─ InitOAuth2FromChannel(channel)                 │
└───────────────────────┬─────────────────────────────┘
                        │ channel.Proxy
┌───────────────────────▼─────────────────────────────┐
│  OAuth2 Manager Layer                               │
│  ├─ NewManagerWithProxy(proxyAddr)                 │
│  └─ TokenRefresher (with proxy)                    │
└───────────────────────┬─────────────────────────────┘
                        │ proxyAddr
┌───────────────────────▼─────────────────────────────┐
│  HTTP Client Layer                                  │
│  ├─ CreateHTTPClientWithProxy(proxyAddr)           │
│  └─ http.Transport (with proxy config)             │
└───────────────────────┬─────────────────────────────┘
                        │
        ┌───────────────┴────────────────┐
        │                                │
┌───────▼────────┐              ┌────────▼────────┐
│  HTTP Proxy    │              │  SOCKS5 Proxy   │
│  (ProxyFunc)   │              │  (DialContext)  │
└───────┬────────┘              └────────┬────────┘
        │                                │
        └───────────────┬────────────────┘
                        │
┌───────────────────────▼─────────────────────────────┐
│  Network Layer (TCP/TLS)                            │
│  └─ Connect to target server via proxy             │
└─────────────────────────────────────────────────────┘
```

### 核心实现

#### 1. HTTP Client 创建（`common/oauth2/http_client.go`）

```go
func CreateHTTPClientWithProxy(proxyAddr string) *http.Client {
    // 创建 Transport，配置代理函数
    transport := &http.Transport{
        DialContext: utils.Socks5ProxyFunc,  // SOCKS5 代理处理
        Proxy:       utils.ProxyFunc,         // HTTP 代理处理
    }

    return &http.Client{
        Transport: transport,
        Timeout:   30 * time.Second,
    }
}
```

#### 2. 代理地址传递（通过 Context）

```go
func WrapRequestWithProxy(ctx context.Context, proxyAddr string) context.Context {
    if proxyAddr == "" {
        return ctx
    }
    return utils.SetProxy(proxyAddr, ctx)
}
```

**为什么使用 Context？**
- Context 是 Go 的标准机制，用于传递请求范围的值
- 每个 HTTP 请求都有自己的 Context
- 避免全局变量，保证线程安全

#### 3. HTTP 代理处理（`common/utils/proxy.go:21-38`）

```go
func ProxyFunc(req *http.Request) (*url.URL, error) {
    // 从请求的 Context 中获取代理地址
    proxyAddr := req.Context().Value(ProxyHTTPAddrKey)
    if proxyAddr == nil {
        return nil, nil  // 没有代理，直连
    }

    // 解析代理 URL
    proxyURL, err := url.Parse(proxyAddr.(string))
    if err != nil {
        return nil, err
    }

    // 验证协议类型
    switch proxyURL.Scheme {
    case "http", "https":
        return proxyURL, nil  // 返回代理 URL，Go 会自动使用
    }

    return nil, fmt.Errorf("unsupported proxy scheme")
}
```

**HTTP 代理工作流程**：
1. 客户端向代理服务器发送 CONNECT 请求
2. 代理服务器建立到目标服务器的连接
3. 代理服务器返回 200 OK
4. 客户端通过隧道发送加密的 HTTPS 流量
5. 代理服务器转发流量（无法解密 HTTPS 内容）

#### 4. SOCKS5 代理处理（`common/utils/proxy.go:40-62`）

```go
func Socks5ProxyFunc(ctx context.Context, network, addr string) (net.Conn, error) {
    // 创建基础 Dialer
    dialer := &net.Dialer{
        Timeout:   5 * time.Second,
        KeepAlive: 30 * time.Second,
    }

    // 从 Context 获取代理地址
    proxyAddr, ok := ctx.Value(ProxySock5AddrKey).(string)
    if !ok {
        return dialer.DialContext(ctx, network, addr)  // 没有代理，直连
    }

    // 解析代理 URL
    proxyURL, _ := url.Parse(proxyAddr)

    // 创建 SOCKS5 Dialer
    proxyDialer, _ := proxy.FromURL(proxyURL, dialer)

    // 通过 SOCKS5 代理建立连接
    return proxyDialer.Dial(network, addr)
}
```

**SOCKS5 代理工作流程**：
1. 客户端向 SOCKS5 服务器发送握手请求
2. 认证（如果需要用户名密码）
3. 客户端发送连接请求（目标地址和端口）
4. SOCKS5 服务器建立连接并返回结果
5. 之后所有数据在客户端和目标服务器之间中转

### 请求流程示例

以刷新 Claude OAuth2 Token 为例：

```
1. 用户配置
   ↓
   channel.Proxy = "http://127.0.0.1:7890"

2. Provider 创建
   ↓
   ClaudeOAuth2ProviderFactory.Create(channel)
   └─ provider.InitOAuth2FromChannel("claude", channel)
      └─ oauth2.NewManagerWithProxy(providerName, refreshToken, proxyAddr)
         └─ NewDefaultRefresherWithProxy(config, proxyAddr)
            └─ CreateHTTPClientWithProxy(proxyAddr)

3. Token 刷新触发
   ↓
   manager.GetAccessToken(ctx)
   └─ refresher.RefreshToken(ctx, refreshToken)
      ├─ ctx = WrapRequestWithProxy(ctx, proxyAddr)  // 添加代理配置
      ├─ req = http.NewRequestWithContext(ctx, "POST", tokenURL, body)
      └─ client.Do(req)

4. HTTP Client 发起请求
   ↓
   Transport.RoundTrip(req)
   └─ Transport.Proxy(req)  // 调用 ProxyFunc
      └─ 返回 proxyURL = "http://127.0.0.1:7890"

5. Go 标准库处理
   ↓
   建立到代理的连接
   └─ CONNECT console.anthropic.com:443 HTTP/1.1
      └─ 代理返回 200 OK
         └─ 建立 TLS 隧道
            └─ 发送 Token 刷新请求

6. Clash 处理（如果使用 Clash）
   ↓
   接收 CONNECT 请求
   └─ 查询规则：console.anthropic.com
      ├─ 匹配规则：PROXY
      └─ 选择节点：最优节点
         └─ 通过节点转发请求
            └─ 返回响应

7. 响应返回
   ↓
   响应数据通过代理隧道返回
   └─ Go HTTP Client 接收响应
      └─ OAuth2 Manager 解析 Token
         └─ 更新 access_token
```

## 代理配置最佳实践

### 1. 选择合适的代理协议

| 协议 | 优点 | 缺点 | 推荐场景 |
|------|------|------|----------|
| HTTP | 简单易用，兼容性好 | 仅支持 HTTP/HTTPS | Clash、V2Ray 等提供的本地代理 |
| SOCKS5 | 底层协议，支持 TCP/UDP | 配置稍复杂 | 需要更底层的控制 |

### 2. Clash 配置建议

**推荐使用 HTTP 代理**：
```
http://127.0.0.1:7890
```

**原因**：
- Clash 的 HTTP 代理功能完整
- One Hub 的请求都是 HTTPS
- HTTP 代理对 HTTPS 的支持是标准化的（CONNECT 隧道）

### 3. 性能优化

**Connection Pool**：
- Go 的 `http.Transport` 自动维护连接池
- 代理连接会被复用
- 减少握手开销

**Timeout 设置**：
```go
client := &http.Client{
    Transport: transport,
    Timeout:   30 * time.Second,  // 请求超时
}

dialer := &net.Dialer{
    Timeout:   5 * time.Second,   // 连接超时
    KeepAlive: 30 * time.Second,  // 保活时间
}
```

### 4. 故障排查

**测试代理是否可用**：
```bash
# 测试 HTTP 代理
curl -x http://127.0.0.1:7890 https://console.anthropic.com

# 测试 SOCKS5 代理
curl --socks5 127.0.0.1:7891 https://console.anthropic.com
```

**检查 Clash 状态**：
1. 打开 Clash Dashboard（通常是 http://127.0.0.1:9090/ui）
2. 查看连接列表，确认请求是否通过代理
3. 查看日志，排查连接失败原因

## 安全性说明

### HTTPS 加密

即使使用 HTTP 代理，HTTPS 请求的**内容仍然是加密**的：

```
┌──────────────┐     HTTP CONNECT     ┌─────────┐
│  One Hub     │ ───────────────────> │  Proxy  │
└──────────────┘                      └─────────┘
       │                                    │
       │    TLS Handshake (encrypted)      │
       │ <─────────────────────────────────┤
       │                                    │
       │    HTTPS Request (encrypted)      │
       │ ───────────────────────────────> │
       │                                    │
```

**代理服务器无法解密**：
- OAuth2 Token 交换请求
- API 请求内容
- 响应数据

**代理服务器可以看到**：
- 目标域名（console.anthropic.com）
- 连接时间和持续时间
- 流量大小

### 认证代理

如果代理需要认证，在 URL 中包含凭证：
```
http://username:password@proxy.example.com:8080
```

**注意事项**：
- 凭证会在 HTTP CONNECT 请求中以 Base64 编码发送
- 如果代理不是本地的，建议使用加密通道
- 避免在日志中记录包含凭证的代理 URL

## 总结

### 核心优势

1. **透明性**：应用层无需关心代理细节，由 HTTP Client 自动处理
2. **灵活性**：支持多种代理协议（HTTP/HTTPS/SOCKS5）
3. **兼容性**：完美兼容 Clash、V2Ray、Shadowsocks 等代理工具
4. **安全性**：HTTPS 加密保护敏感数据
5. **易用性**：只需配置一个 URL，API 和 OAuth2 自动使用

### 适用场景

✅ **适用**：
- 网络受限环境（防火墙/GFW）
- 需要通过跳板机访问
- 使用代理工具（Clash/V2Ray）
- 企业内网环境

❌ **不需要**：
- 网络可以直连目标服务器
- 本地开发测试环境
- 已经有系统级代理配置
