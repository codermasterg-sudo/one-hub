.PHONY: help init start stop restart logs status clean backup restore update health check-config generate-keys

# 默认目标
.DEFAULT_GOAL := help


# 项目配置
PROJECT_NAME := one-hub
COMPOSE_FILE := docker-compose.prod.yml
ENV_FILE := .env.production
BACKUP_DIR := ./backups
DATA_DIR := ./data
LOGS_DIR := ./logs

##@ 帮助信息

help: ## 显示此帮助信息
	@echo "╔════════════════════════════════════════════════════════╗"
	@echo "║          One Hub 生产环境部署管理工具                  ║"
	@echo "╚════════════════════════════════════════════════════════╝"
	@echo ""
	@awk 'BEGIN {FS = ":.*##"; printf "使用方式: make -f Makefile.prod <target>\n\n"} /^[a-zA-Z_-]+:.*?##/ { printf "  %-20s %s\n", $$1, $$2 } /^##@/ { printf "\n%s\n", substr($$0, 5) } ' $(MAKEFILE_LIST)

##@ 初始化部署

init: ## 初始化生产环境（首次部署时运行）
	@echo ">>> 开始初始化生产环境..."
	@$(MAKE) -f Makefile.prod check-docker
	@$(MAKE) -f Makefile.prod create-dirs
	@$(MAKE) -f Makefile.prod generate-keys
	@$(MAKE) -f Makefile.prod check-env
	@echo ">>> 初始化完成！"
	@echo ">>> 配置文件: $(ENV_FILE)"
	@echo ">>> 如需修改配置，请编辑该文件后运行: make -f Makefile.prod start"

check-docker: ## 检查 Docker 和 Docker Compose 是否安装
	@echo ">>> 检查 Docker 环境..."
	@command -v docker >/dev/null 2>&1 || { echo "错误: 未找到 Docker，请先安装"; exit 1; }
	@command -v docker-compose >/dev/null 2>&1 || { echo "错误: 未找到 Docker Compose，请先安装"; exit 1; }
	@docker ps >/dev/null 2>&1 || { echo "错误: Docker 未运行或无权限访问"; exit 1; }
	@echo "✓ Docker 环境检查通过"

create-dirs: ## 创建必要的目录
	@echo ">>> 创建目录结构..."
	@mkdir -p $(DATA_DIR)/mysql $(DATA_DIR)/redis $(DATA_DIR)/app $(LOGS_DIR) $(BACKUP_DIR) scripts
	@chmod 755 $(DATA_DIR) $(LOGS_DIR) $(BACKUP_DIR)
	@echo "✓ 目录创建完成"

generate-keys: ## 生成安全密钥
	@echo ">>> 检查配置文件..."
	@if [ -f $(ENV_FILE) ]; then \
		echo "╔════════════════════════════════════════════════════════╗"; \
		echo "║                  ⚠️ 安全警告 ⚠️                         ║"; \
		echo "╚════════════════════════════════════════════════════════╝"; \
		echo ""; \
		echo "检测到已存在配置文件: $(ENV_FILE)"; \
		echo ""; \
		echo "重要提示:"; \
		echo "  • 重新生成配置将导致所有用户 Token 失效"; \
		echo "  • USER_TOKEN_SECRET 一旦修改无法恢复"; \
		echo "  • 数据库连接信息将被重置"; \
		echo ""; \
		echo "请选择操作:"; \
		echo "  1) 保留现有配置（推荐）"; \
		echo "  2) 备份后生成新配置"; \
		echo "  3) 直接覆盖（危险！）"; \
		echo ""; \
		read -p "请选择 (1/2/3) [1]: " choice; \
		choice=$${choice:-1}; \
		case $$choice in \
			1) \
				echo "✓ 保留现有配置"; \
				exit 0; \
				;; \
			2) \
				backup_file="$(ENV_FILE).backup.$$(date +%Y%m%d_%H%M%S)"; \
				cp $(ENV_FILE) $$backup_file; \
				echo "✓ 配置已备份到: $$backup_file"; \
				echo ">>> 将生成新配置文件"; \
				;; \
			3) \
				echo ">>> 警告: 即将覆盖现有配置！"; \
				read -p "请输入 'YES' 确认: " confirm; \
				if [ "$$confirm" != "YES" ]; then \
					echo "操作已取消"; \
					exit 0; \
				fi; \
				;; \
			*) \
				echo "无效选择，保留现有配置"; \
				exit 0; \
				;; \
		esac; \
	fi
	@echo ">>> 生成安全密钥..."
	@if [ ! -f scripts/generate-env.sh ]; then \
		echo "错误: 未找到 scripts/generate-env.sh"; \
		echo "请确保该文件存在，或重新克隆项目"; \
		exit 1; \
	fi
	@bash scripts/generate-env.sh > $(ENV_FILE)
	@echo "✓ 配置文件已生成: $(ENV_FILE)"
	@echo ""
	@echo "╔════════════════════════════════════════════════════════╗"
	@echo "║           ⚠️ 请妥善保管配置文件 ⚠️                      ║"
	@echo "╚════════════════════════════════════════════════════════╝"
	@echo ""
	@echo "配置文件包含敏感信息，请勿提交到代码仓库！"
	@echo "配置文件位置: $(ENV_FILE)"

check-env: ## 检查环境变量配置
	@echo ">>> 检查环境变量配置..."
	@if [ ! -f $(ENV_FILE) ]; then \
		echo "错误: 未找到配置文件 $(ENV_FILE)"; \
		echo "请运行: make -f Makefile.prod init"; \
		exit 1; \
	fi
	@echo "✓ 环境变量配置存在"

##@ 服务管理

start: check-env ## 启动所有服务
	@echo ">>> 启动 $(PROJECT_NAME) 服务..."
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) up -d
	@echo ">>> 服务启动成功！"
	@echo ">>> 等待服务就绪..."
	@sleep 10
	@$(MAKE) -f Makefile.prod health

stop: ## 停止所有服务
	@echo ">>> 停止 $(PROJECT_NAME) 服务..."
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) down
	@echo ">>> 服务已停止"

restart: ## 重启所有服务
	@echo ">>> 重启 $(PROJECT_NAME) 服务..."
	@$(MAKE) -f Makefile.prod stop
	@sleep 3
	@$(MAKE) -f Makefile.prod start

restart-app: ## 仅重启应用服务（不重启数据库和 Redis）
	@echo ">>> 重启应用服务..."
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) restart one-hub
	@sleep 5
	@$(MAKE) -f Makefile.prod health

##@ 日志和监控

logs: ## 查看所有服务日志
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) logs -f

logs-app: ## 查看应用日志
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) logs -f one-hub

logs-mysql: ## 查看 MySQL 日志
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) logs -f mysql

logs-redis: ## 查看 Redis 日志
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) logs -f redis

status: ## 查看服务状态
	@echo ">>> 服务状态"
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) ps

health: ## 检查服务健康状态
	@echo ">>> 检查服务健康状态..."
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) ps | grep -q "healthy" && \
		echo "✓ 容器健康检查通过" || \
		echo "⚠ 部分容器可能未就绪"
	@echo ""
	@echo ">>> 应用健康检查..."
	@sleep 2
	@curl -sf http://localhost:3000/api/status >/dev/null 2>&1 && \
		echo "✓ 应用运行正常" || \
		echo "✗ 应用健康检查失败"

stats: ## 查看资源使用情况
	@docker stats --no-stream $$(docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) ps -q 2>/dev/null)

##@ 数据库管理

db-shell: ## 进入 MySQL 命令行
	@echo ">>> 进入 MySQL 命令行..."
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) exec mysql mysql -u oneapi -p

redis-shell: ## 进入 Redis 命令行
	@echo ">>> 进入 Redis 命令行..."
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) exec redis redis-cli

db-backup: ## 备份数据库
	@echo ">>> 开始备份数据库..."
	@bash scripts/backup.sh
	@echo ">>> 备份完成！"

db-restore: ## 恢复数据库（需要指定备份文件：make db-restore BACKUP=xxx.sql.gz）
	@if [ -z "$(BACKUP)" ]; then \
		echo "错误: 请指定备份文件"; \
		echo "使用方式: make -f Makefile.prod db-restore BACKUP=backups/one-api-20240101_120000.sql.gz"; \
		echo ""; \
		echo "可用的备份文件:"; \
		ls -lh $(BACKUP_DIR)/*.sql.gz 2>/dev/null || echo "  无备份文件"; \
		exit 1; \
	fi
	@echo ">>> 恢复数据库: $(BACKUP)"
	@bash scripts/restore.sh $(BACKUP)
	@echo ">>> 恢复完成！"

##@ 更新和维护

update: ## 更新到最新版本
	@echo ">>> 拉取最新镜像..."
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) pull
	@echo ">>> 备份当前数据..."
	@$(MAKE) -f Makefile.prod db-backup
	@echo ">>> 重启服务..."
	@$(MAKE) -f Makefile.prod restart
	@echo ">>> 更新完成！"

upgrade: update ## 更新的别名

pull: ## 拉取最新镜像（不重启）
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) pull

##@ 清理和维护

clean: ## 清理未使用的 Docker 资源
	@echo ">>> 清理未使用的 Docker 资源..."
	@docker system prune -f
	@echo ">>> 清理完成"

clean-all: ## 清理所有数据（危险操作！）
	@echo "╔════════════════════════════════════════════════════════╗"
	@echo "║                  ⚠️ 危险操作 ⚠️                         ║"
	@echo "╚════════════════════════════════════════════════════════╝"
	@echo ""
	@echo "此操作将删除所有数据，包括:"
	@echo "  • 数据库数据"
	@echo "  • Redis 缓存"
	@echo "  • 应用数据"
	@echo "  • 日志文件"
	@echo ""
	@echo "请输入项目名称 '$(PROJECT_NAME)' 确认:"
	@read -r confirm; \
	if [ "$$confirm" = "$(PROJECT_NAME)" ]; then \
		echo ">>> 停止服务..."; \
		$(MAKE) -f Makefile.prod stop; \
		echo ">>> 删除数据..."; \
		docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) down -v; \
		rm -rf $(DATA_DIR)/* $(LOGS_DIR)/*; \
		echo ">>> 清理完成"; \
	else \
		echo "确认失败，操作已取消"; \
	fi

logs-clean: ## 清理旧日志文件（保留最近7天）
	@echo ">>> 清理旧日志文件..."
	@find $(LOGS_DIR) -name "*.log*" -mtime +7 -delete 2>/dev/null || true
	@echo ">>> 日志清理完成"

##@ 开发和调试

shell: ## 进入应用容器 shell
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) exec one-hub /bin/sh

inspect: ## 查看应用容器详细信息
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) exec one-hub cat /etc/os-release || true
	@echo ""
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) exec one-hub ps aux || true

config: ## 显示完整的 Docker Compose 配置
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) config

validate: ## 验证 Docker Compose 配置
	@echo ">>> 验证配置文件..."
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) config -q && \
		echo "✓ 配置文件验证通过" || \
		echo "✗ 配置文件验证失败"

##@ 快捷操作

dev: ## 开发模式（显示日志）
	@docker compose -f $(COMPOSE_FILE) --env-file $(ENV_FILE) up

ps: status ## 查看服务状态（status 的别名）

down: stop ## 停止服务（stop 的别名）

up: start ## 启动服务（start 的别名）

top: stats ## 查看资源使用（stats 的别名）

##@ 打包和分发

package: ## 打包生产环境部署文件
	@echo ">>> 开始打包生产环境..."
	@bash scripts/package-prod.sh

package-check: ## 检查打包文件
	@if [ -f dist/*.tar.gz ]; then \
		echo ">>> 打包文件:"; \
		ls -lh dist/*.tar.gz; \
		echo ""; \
		echo ">>> MD5 校验:"; \
		cat dist/*.tar.gz.md5 2>/dev/null || echo "  无校验文件"; \
	else \
		echo "未找到打包文件，请先运行: make -f Makefile.prod package"; \
	fi

package-extract: ## 解压查看打包内容（需要指定 FILE=xxx.tar.gz）
	@if [ -z "$(FILE)" ]; then \
		echo "错误: 请指定文件"; \
		echo "使用方式: make -f Makefile.prod package-extract FILE=dist/xxx.tar.gz"; \
		exit 1; \
	fi
	@echo ">>> 解压 $(FILE)..."
	@tar -tzf $(FILE) | head -30
	@echo ""
	@echo "... (总共 $$(tar -tzf $(FILE) | wc -l) 个文件)"

package-clean: ## 清理打包文件
	@echo ">>> 清理打包文件..."
	@rm -rf ./dist
	@echo "✓ 清理完成"
